#!/bin/bash
# A.R.B. Automatic Robust Backup

# LIB
arb_tmp=/run/user/$(id -u)/arb

verifySrc() { # args: $name or $path
    if [ -d "$1" ]; then
        printf "%s\n" "$1"
    else
        printf "%s\n" "$arb_tmp/$1"
    fi
}

umountCrypt() { # args: $name
# Unmount a Gocryptfs directory 
    mount="$arb_tmp"/$1
	([ -d "$mount" ] && fusermount -uz "$mount") || # try to unmount if it exists
    (printf "<3>ERROR: %s\n" "unmounting $1 failed"; return 1) # print and return error if it fails 
	[ -n "$(ls -A "$mount")" ] || rm -r "$mount" # remove dir if empty
}

mountCrypt() { # args: # name $src $pass $exclude(opt)
# Mount a Gocryptfs directory
    mount="$arb_tmp"/$1
	if [ -d "$mount" ] && [[ -n "$(ls -A "$mount")" ]]; then # if dst exists and is not empty
        printf "<4>WARNING: %s\n" "$1 is already mounted, unmounting..."
        (umountCrypt "$1" && sleep 2) || return 1 # unmount if already mounted
    fi
	
    if ! [ -d "$2" ]; then # check if src dir exists
        printf "<3>ERROR: %s\n" "$2 does not exist!" && return 1
    fi
    
    mkdir -p "$mount" # create mountpoint dir if inexistent
	if [ "$4" ]; then # mount reverse encrypted
		gocryptfs -extpass pass -extpass "$3" -exclude-from "$4" -reverse "$2" "$mount"
	else
		gocryptfs -extpass pass -extpass "$3" -reverse "$2" "$mount"
	fi
}

syncDisk() { #args: $src $dst
# Sync a dir to disk
    src=$(verifySrc "$1")
	rsync -a --delete "$src" "$2"
}

syncCloud() { # syncCloud $name $stream $src(opt)
# Sync a dir to a cloud bucket
    if [ "$3" ]; then
        src=$(verifySrc "$3")
    else 
        src=$(verifySrc "$1")
    fi
	printf "<5>NOTICE: %s\n" "syncing $1 to $2"
	#rclone sync -u --use-server-modtime --skip-links --fast-list --max-backlog=-1 "$2/" "$3:$1/"
	rclone sync -u --use-server-modtime --skip-links --fast-list "$src/" "$2:$1/"
}

archiveSys() { # args: $repo $exclude
# Archive system confs 
	mkdir -p "$1" # make dir if inexistent
	pacman -Qqen > "$1/pkglist.txt" # export non-local pkg list
	pacman -Qqem > "$1/pkglist-local.txt" # export local pkg list
	export CVSIGNORE="$2" && rsync -qaH --delete -C /etc/ "$1/etc/" # sync /etc
	git -C "$1" add -A && git -C "$1" commit -m "$(date +%Y-%m-%d)" # archive changes in git
}

# TODO: Use etckeeper to archive system /etc
# https://wiki.archlinux.org/index.php/Etckeeper 

archiveBorg() { # args: $borg_repo $borg_exclude $src $borg_pass(opt) $borg_key(opt)
# Archive a dir with borg (default)
    export BORG_REPO="$1"
	[ "$4" ] && export BORG_PASSCOMMAND="pass $4"
	[ "$5" ] && export BORG_KEY_FILE="$5"
	borg create -s -x -C lz4 --exclude-from "$2" "::{user}-{now:%y-%m-%d}" "$3" # archive
	borg prune --list --keep-daily=7 --keep-weekly=4 --keep-monthly=6 # purge old
}

archiveBorgLite() { # $borg_repo $borg_exclude $src $borg_pass(opt) $borg_key(opt)
    # Archive a dir with borg (higher compression and chunk granularity)
	export BORG_REPO="$1"
	[ "$4" ] && export BORG_PASSCOMMAND="pass $4"
	[ "$5" ] && export BORG_KEY_FILE="$5"
	borg create -s -x -C auto,lzma --exclude-from "$2" --chunker-params 10,23,16,4095 "::{user}-{now:%y-%m-%d}" "$3" # archive with higher compression and fine granularity
	borg prune --list --keep-last=3 # purge old
}

# Decorate
decorate() { # args: function
# Decorator for logging
    eval "
        _inner_$(typeset -f "$1")
        $1"'() {
            printf >&2 "<5>NOTICE: %s\n" "'$1' started"
            _inner_'$1' "$@"
            local ret=$?
            printf >&2 "<5>NOTICE: %s\n" "'$1' ended with status $ret"
            return "$ret"
        }'
}

# MAIN
# Exit without doing anything if already being executed
for pid in $(pidof -x arb); do 
    if [ "$pid" != $$ ]; then
	    printf "<3>ERROR: %s\n" "program is already running with PID '"$pid"'!"
        exit 1
    fi
done

# Trap ^C to allow forceful exit from child
trap ctrl_c INT 
ctrl_c() {
    kill -15 "$child" && wait "$child" # send SIGTERM to child process

    # loop through existent dirs and try to umount/rm them
    mapfile -t mounts < <(fd --type d --max-depth 1 --base-directory "$arb_tmp")
    for mount in "${mounts[@]}"; do
        umountCrypt "$mount"
    done

    [ "$mount" ] && umountCrypt "$mount" # unmount last mount point
    printf "<3>ERROR: %s\n" "program with PID '"$child"' was manually terminated!"
    exit 1
}

# Decorate functions with logging
decorate syncDisk
decorate syncCloud
decorate archiveSys
decorate archiveBorg
decorate archiveBorgLite

# Source variables and commands from config file
config="$HOME/.config/arb/config"
if [ -f "$config" ]; then # exit with config not found
    source "$config"
else
    printf "<3>ERROR: %s\n" "config file not found!"
    exit 1
fi
