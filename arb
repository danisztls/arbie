#!/bin/bash
# A.R.B. Automatic Robust Backup

# LIB 
# TODO: Automatically create unmount all dirs at /run/user/$uid/arb/ 
umountCrypt() { # args: $mount
# Unmount a Gocryptfs directory 
	([ -d "$1" ] && fusermount -uz "$1") || (printf "<3>ERROR: %s\n" "unmounting $1 failed"; return 1)
	[ -n "$(ls -A "$1")" ] || rm -r "$1" # remove dir if empty
}

# TODO: Automatically create a mount at /run/user/$uid/arb/repo_name 
mountCrypt() { # args: $src $mount_point $pass $exclude(opt)
# Mount a Gocryptfs directory
	[ -d "$2" ] && [[ -n "$(ls -A "$2")" ]] &&
    (printf "<4>WARNING: %s\n" "$2 is already mounted, unmounting..."; (umountCrypt "$2" && sleep 2) || return 1) # unmount if already mounted
	# FIXME: Use IF instead of branching
    mkdir -p "$2" # make dir if inexistent
	if [ "$4" ]; then # mount reverse encrypted
		gocryptfs -extpass pass -extpass "$3" -exclude-from "$4" -reverse "$1" "$2"
	else
		gocryptfs -extpass pass -extpass "$3" -reverse "$1" "$2"
	fi
}

syncDisk() { #args: $src $dst
# Sync a dir to disk
	rsync -a --delete "$1" "$2"
}

syncCloud() { # syncCloud $name $src $stream
# Sync a dir to a cloud bucket
	printf "<5>NOTICE: %s\n" "syncing $1 to $3"
	#rclone sync -u --use-server-modtime --skip-links --fast-list --max-backlog=-1 "$2/" "$3:$1/"
	rclone sync -u --use-server-modtime --skip-links --fast-list -v "$2/" "$3:$1/"
}

archiveSys() { # args: $repo $exclude
# Archive system confs 
	mkdir -p "$1" # make dir if inexistent
	pacman -Qqen > "$1/pkglist.txt" # export non-local pkg list
	pacman -Qqem > "$1/pkglist-local.txt" # export local pkg list
	export CVSIGNORE="$2" && rsync -qaH --delete -C /etc/ "$1/etc/" # sync /etc
	git -C "$1" add -A && git -C "$1" commit -m "$(date +%Y-%m-%d)" # archive changes in git
}

# TODO: Use etckeeper to archive system /etc
# https://wiki.archlinux.org/index.php/Etckeeper 

archiveBorg() { # args: $borg_repo $borg_exclude $src $borg_pass(opt) $borg_key(opt)
# Archive a dir with borg (default)
    export BORG_REPO="$1"
	[ "$4" ] && export BORG_PASSCOMMAND="pass $4"
	[ "$5" ] && export BORG_KEY_FILE="$5"
	borg create -s -x -C lz4 --exclude-from "$2" "::{user}-{now:%y-%m-%d}" "$3" # archive
	borg prune --list --keep-daily=7 --keep-weekly=4 --keep-monthly=6 # purge old
}

archiveBorgLite() { # $borg_repo $borg_exclude $src $borg_pass(opt) $borg_key(opt)
    # Archive a dir with borg (higher compression and chunk granularity)
	export BORG_REPO="$1"
	[ "$4" ] && export BORG_PASSCOMMAND="pass $4"
	[ "$5" ] && export BORG_KEY_FILE="$5"
	borg create -s -x -C auto,lzma --exclude-from "$2" --chunker-params 10,23,16,4095 "::{user}-{now:%y-%m-%d}" "$3" # archive with higher compression and fine granularity
	borg prune --list --keep-last=1 # purge old
}

# Decorate
decorate() { # args: function
# Decorator for logging
    eval "
        _inner_$(typeset -f "$1")
        $1"'() {
            printf >&2 "<5>NOTICE: %s\n" "'$1' started"
            _inner_'$1' "$@"
            local ret=$?
            printf >&2 "<5>NOTICE: %s\n" "'$1' ended with status $ret"
            return "$ret"
        }'
}

# MAIN
# Exit without doing anything if already being executed
for pid in $(pidof -x arb); do 
    if [ "$pid" != $$ ]; then
	    printf "<3>ERROR: %s\n" "program is already running with PID '"$pid"'!"
        exit 1
    fi
done

# Trap ^C to allow forceful exit from child
trap ctrl_c INT 
ctrl_c() {
    kill -15 "$child" && wait "$child" # send SIGTERM to child process
    [ "$mount" ] && umountCrypt "$mount" # unmount last mount point
    printf "<3>ERROR: %s\n" "program with PID '"$child"' was manually terminated!"
    exit 1
}

# Decorete functions with logging
decorate syncDisk
decorate syncCloud
decorate archiveSys
decorate archiveBorg
decorate archiveBorgLite

# Source variables and commands from config file
config="$HOME/.config/arb/config"
if [ -f "$config" ]; then # exit with config not found
    source "$config"
else
    printf "<3>ERROR: %s\n" "config file not found!"
    exit 1
fi
